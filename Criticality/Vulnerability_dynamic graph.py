#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Mon Jul 24 10:42:50 2017

@author: yan
"""

get_ipython().magic(u'matplotlib inline')
from matplotlib import pyplot as plt
import networkx as nx
import pandas as pd
import copy
import time 
import csv

import os
import sys

from collections import Counter

module_path = os.path.abspath(os.path.join('..'))
if module_path not in sys.path:
    sys.path.append(module_path)
file_dir = os.path.dirname(os.path.realpath('_file_'))
if file_dir not in sys.path:
    sys.path.append(file_dir)
file_dir = os.path.abspath(os.path.join('network_lib'))
if file_dir not in sys.path:
    sys.path.append(file_dir)

#Modules developed by TU Delft team for thiss project
from network_lib import network_prep as net_p
from network_lib import network_visualization as net_v
from network_lib import od_prep as od_p
#from network_lib import weighted_betweenness as betw_w

import geopandas as gp
import numpy as np
from simpledbf import Dbf5
#from gurobipy import *
# In[]: Network Preparation
network = r'./input/fiji_south/fj_roads_south_FRA_v4.shp'
centroid = r'./input/fiji_south/OD_south_10Cities.shp'
dbf = Dbf5(r'./input/fiji_south/fj_bridges_south_FRA_v1.dbf')
df_structure = dbf.to_dataframe()
gdf_points, gdf_node_pos, gdf = net_p.prepare_centroids_network(centroid, network)
          
# Create Networkx MultiGraph object from the GeoDataFrame
G = net_p.gdf_to_simplified_multidigraph(gdf_node_pos, gdf, simplify=False)

# Change the MultiGraph object to Graph object to reduce computation cost 
G_tograph = net_p.multigraph_to_graph(G)

# Observe the properties of the Graph object    
#print('number of disconnected compoents is', nx.number_connected_components(G_tograph))
nx.info(G_tograph)

# Take only the largest subgraph which all connected links
len_old = 0
for g in nx.connected_component_subgraphs(G_tograph):
    if len(list(g.edges())) > len_old:
        G1 = g
        len_old = len(list(g.edges()))        
G_sub = G1.copy()

#print('number of disconnected compoents is', nx.number_connected_components(G_sub))
nx.info(G_sub)

# Save the simplified transport network back into GeoDataFrame
gdf_sub = net_p.graph_to_df(G_sub)

# assign the OD to the closest node of the biggest subgraph: 
gdf_points2, gdf_node_pos2, gdf_new=net_p.prepare_newOD(centroid, gdf_sub)
gdf_points2['population'][6]=30000 # the population of Rakiraki is 29700 at 1996 census, 30000 as approximate
G2_multi = net_p.gdf_to_simplified_multidigraph(gdf_node_pos2, gdf_new, simplify=False)
G2 = net_p.multigraph_to_graph(G2_multi)
gdf2 = net_p.graph_to_df(G2)
allNode = G2.nodes()
allEdge = G2.edges()
od = gdf_points2['Node']

# the output of this section is gdf_points2, gdf_node_pos2, gdf2, G2

# In[]: baseline: find the shortest path for each od to minimize the total travel cost; 
# output: 1) baseCost ($): total travel cost between all OD pairs; 2) basePath : the shortest path between all OD pairs   

n=0
basePath = [[[]for i in range(len(od))] for j in range(len(od))]
baseCost=np.zeros((len(od),len(od)))
for i in range(len(od)):    
    for j in range(i+1,len(od)):
        print(n)
        basePath[i][j]=nx.dijkstra_path(G2,od[i],od[j],weight = 'total_cost')
        baseCost[i][j]=nx.dijkstra_path_length(G2,od[i],od[j],weight = 'total_cost')
        n=n+1

# baseline: find the shortest path for each od to minimize the total travel cost; 
# output: 1) baseLength: total travel distance between all OD pairs;
n=0    
baseLength=np.zeros((len(od),len(od)))
for i in range(len(od)):    
    for j in range(i+1,len(od)):
        print(n)
        baseLength[i][j]=nx.dijkstra_path_length(G2,od[i],od[j],weight = 'length')
        n=n+1
        
# In[]:  Dictionary 
stpID = [[]for i in range(45)]
dict_linkNode={}    
for i in range(len(gdf2)):
    a = min(gdf2['FNODE_'][i],gdf2['TNODE_'][i])
    b = max(gdf2['FNODE_'][i],gdf2['TNODE_'][i])
    dict_linkNode[(a,b)] = gdf2['OBJECT_ID'][i]
n=0   
for i in range(len(basePath)):
    for j in range(len(basePath[i])):        
        if len(basePath[i][j])>1:
            for k in range(len(basePath[i][j])-1):   
                a = min(basePath[i][j][k],basePath[i][j][k+1])
                b = max(basePath[i][j][k],basePath[i][j][k+1])
                stpID[n].append(dict_linkNode[(a,b)])                
            n+=1
            
# In[]:
################### traffic flow matrix ####################################################
# OD table 
k=1.3
popu={}

for i in range(len(od)):
    idx = gdf_points2['Node'].tolist().index(od[i])
    popu[od[i]]=gdf_points2['population'].tolist()[idx]
    
T=np.zeros((len(od),len(od)))  # identical with OD order      
for i in range(len(od)):
    for j in range(i+1,len(od)):
        T[i][j]= k*popu[od[i]]*popu[od[j]]/baseLength[i][j]/30*1e3 # AADT (travel per day)

# In[]
# build a dictionary to match structure (key) and F,TNODE_ (value); structure type, and index in df_structure
dic_strNode={} # structure ID to FNODE_, TNODE_ of the link
dic_strType={} # structure ID to type
dic_strID={} # structure and index in df_structure
dic_linkID={} # link object ID to row number
dic_strLink={} # structure ID to link ID
for i in range(len(df_structure)):
    dic_strID[df_structure['OBJECTID'][i]]=i 
    dic_strType[df_structure['OBJECTID'][i]] = df_structure['StructureT'][i] 
    dic_strLink[df_structure['OBJECTID'][i]] = df_structure['LINK_ID'][i]
    
    if df_structure['LINK_ID'][i] in gdf2['OBJECT_ID'].tolist():
        idx = gdf2['OBJECT_ID'][gdf2['OBJECT_ID'] == df_structure['LINK_ID'][i]].index[0]
        dic_linkID[df_structure['OBJECTID'][i]] = idx
        node = (gdf2['FNODE_'][idx],gdf2['TNODE_'][idx])
        dic_strNode[df_structure['OBJECTID'][i]]=node

# dictionary for link to all structure
dic_linkStr={} # link ID to ID of all structures in the link
for i in range(len(df_structure)):
    item = df_structure['LINK_ID'][i]
    if item in dic_linkStr:
        dic_linkStr[item].append(df_structure['OBJECTID'][i])#[dic_linkStr[item],df_structure['OBJECTID'][i]]
    else:
        dic_linkStr[item] = [df_structure['OBJECTID'][i]]
         
# In[]: water flood user disruption cost
#def floodDisrupt(r):
# assumption: when a structure in the link is being disrupted, the link is disrupted   
# structure threshold: bridge 50, culvert 20, crossing 5 return period
# this function consider the repair duration: if bridge is damaged, ...
#it takes 180 days to repair, culvert: 31 day, crossing: 7 days 

def disrupt(r,graph,penalty,curIvtSet,baseline):
    # Input:
    #       r: return period
    #       graph: original traffic network
    #       penalty: penalty user cost for isolating od trip
    #       curIvtSet: links already invested
    #       baseline: cost with no link disruption
    # Output:
    #       diff: difference of total user cost under flood r vs. baseline
    #       isoTrip_sum: total # of isolated trips under r
    #       link_damage: ID of damaged links
    #       stru_damage: ID of damaged structures
    #       repC_link: repair cost per link
     
    bridgeRC = 40000 # repair cost $
    culvertRC = 10000
    crossingRC = 1000
    
    stru_damage=set()    # ID of the bridge disrupted in that return period
    link_damage=[]    # OBJECT_ID of the road disrupted in that return period:
    repairC1 = [] # total repair cost in that return period (bridge)
    repairC2 = [] # (culvert)
    repairC3 = [] # crossing
    repC_link = {}
    dic_graph = {}
    
    bridge_set=set()
    culvert_set=set()
    cross_set=set()
    isoTrip_sum=[0,0,0]
    diff = [0, 0, 0]
    num = [0, 0, 0]
    
    G = copy.deepcopy(graph)
    
    for link, strList in dic_linkStr.items():
        for item in strList:
            if dic_strType[item] == 'Bridge' or dic_strType[item] == 'Footbridge': 
                bridge_set.add(item)
            elif dic_strType[item] == 'Culvert':
                culvert_set.add(item)
            else:
                cross_set.add(item)
    
    for item in bridge_set:
        if dic_strNode.get(item,0)==0: continue
        i = dic_strID[item]
        if df_structure[r][i]>df_structure['WD_PU_100'][i] or \
            (item not in curIvtSet and df_structure[r][i]>df_structure['WD_PU_50'][i]):
            stru_damage.add(item)
            if not dic_strLink[item] in link_damage:
                link_damage.append(dic_strLink[item])
            
            G[dic_strNode[item][0]][dic_strNode[item][1]]['total_cost']=1e10
            cost = (df_structure[r][i] - df_structure['WD_PU_50'][i])/(df_structure['WD_PU_1000'][i] \
                       - df_structure['WD_PU_50'][i])*1*bridgeRC*float(df_structure['Length'][i])*\
                       float(df_structure['TotalWidth'][i])                            
            repairC1.append(cost) 
            repC_link[dic_strLink[item]] = repC_link.get(dic_strLink[item],0)+cost
    
    dic_graph['Bridge'] = copy.deepcopy(G)
    to_allNode = []   
    for j in range(len(od)): 
        to_allNode.append(nx.single_source_dijkstra_path_length(G,od[j],weight = 'total_cost'))       

    cost_disrupt= np.zeros((len(od),len(od)))                 
    for j in range(len(to_allNode)):
        for k in range(len(od)):
            if k>j:
               cost_disrupt[j][k] = to_allNode[j].get(od[k])
    cost_disrupt -= baseline
    for index, item in np.ndenumerate(cost_disrupt):
        if item>=1e9:
            cost_disrupt[index]=penalty
            isoTrip_sum[0] += T[index] * 150 / 1e6
            #isoTrip_sum[0] += T[index] / 1e6           
            
    diff[0] = np.sum(np.multiply(cost_disrupt, T)) * 150 / 1e6
    num[0] =  np.sum(np.multiply(cost_disrupt>0, T)) * 150 / 1e6   
               
    for item in culvert_set:
        if dic_strNode.get(item,0)==0: continue
        i = dic_strID[item]
        if df_structure[r][i]>df_structure['WD_PU_50'][i] or \
            (item not in curIvtSet and df_structure[r][i]>df_structure['WD_PU_20'][i]):
            stru_damage.add(item)
            if not dic_strLink[item] in link_damage:
                link_damage.append(dic_strLink[item])
            
            G[dic_strNode[item][0]][dic_strNode[item][1]]['total_cost']=1e10
            cost = (df_structure[r][i] - df_structure['WD_PU_20'][i])/(df_structure['WD_PU_1000'][i] \
                       - df_structure['WD_PU_20'][i])*1*culvertRC*float(df_structure['Length'][i])*\
                       float(df_structure['TotalWidth'][i])                            
            repairC2.append(cost) 
            repC_link[dic_strLink[item]] = repC_link.get(dic_strLink[item],0)+cost
    
    dic_graph['Culvert'] = copy.deepcopy(G)        
    to_allNode = []
    for j in range(len(od)): 
        to_allNode.append(nx.single_source_dijkstra_path_length(G,od[j],weight = 'total_cost'))       

    cost_disrupt= np.zeros((len(od),len(od)))                 
    for j in range(len(to_allNode)):
        for k in range(len(od)):
            if k>j:
               cost_disrupt[j][k] = to_allNode[j].get(od[k])
    cost_disrupt -= baseline
    for index, item in np.ndenumerate(cost_disrupt):
        if item>=1e9:
            cost_disrupt[index]=penalty
            isoTrip_sum[1] += T[index] * 24 / 1e6
            #isoTrip_sum[1] += T[index] / 1e6           
            
    diff[1] = np.sum(np.multiply(cost_disrupt, T)) * 24 / 1e6
    num[1] =  np.sum(np.multiply(cost_disrupt>0, T)) * 24 / 1e6
           
    for item in cross_set:
        if dic_strNode.get(item,0)==0: continue
        i = dic_strID[item]
        if df_structure[r][i]>df_structure['WD_PU_10'][i] or \
            (item not in curIvtSet and df_structure[r][i]>df_structure['WD_PU_5'][i]):
            stru_damage.add(item)
            if not dic_strLink[item] in link_damage:
                link_damage.append(dic_strLink[item])
            
            G[dic_strNode[item][0]][dic_strNode[item][1]]['total_cost']=1e10
            l = float(df_structure['Length'][i]) 
            if np.isnan(l):
                l=10
            b = float(df_structure['TotalWidth'][i] )
            if np.isnan(b):
                b=3   
                
            cost = (df_structure[r][i] - df_structure['WD_PU_5'][i])/(df_structure['WD_PU_1000'][i] \
                       - df_structure['WD_PU_5'][i])*1*crossingRC*l*b                  
            repairC3.append(cost)                 
            repC_link[dic_strLink[item]] = repC_link.get(dic_strLink[item],0)+cost            
    
    dic_graph['Crossing'] = copy.deepcopy(G)                 
    to_allNode = []  
    for j in range(len(od)): 
        to_allNode.append(nx.single_source_dijkstra_path_length(G,od[j],weight = 'total_cost'))       

    cost_disrupt= np.zeros((len(od),len(od)))                 
    for j in range(len(to_allNode)):
        for k in range(len(od)):
            if k>j:
               cost_disrupt[j][k] = to_allNode[j].get(od[k])
    cost_disrupt -= baseline
    for index, item in np.ndenumerate(cost_disrupt):
        if item>=1e9:
            cost_disrupt[index]=penalty
            isoTrip_sum[2] += T[index] * 7 / 1e6
            #isoTrip_sum[2] += T[index]  / 1e6           
            
    diff[2] = np.sum(np.multiply(cost_disrupt, T)) * 7 / 1e6
    num[2] =  np.sum(np.multiply(cost_disrupt>0, T)) *  7 / 1e6
    
    reBridge_s = np.sum(repairC1)/1e6  
    reCulvert_s = np.sum(repairC2)/1e6  
    reCrossing_s = np.sum(repairC3)/1e6      
    
       
    return diff, num, isoTrip_sum,link_damage,stru_damage,repC_link,reBridge_s,reCulvert_s,reCrossing_s 
# In[]: water flood user disruption cost 
# expected annual user 
rperiod = ['WD_PU_5','WD_PU_10','WD_PU_20','WD_PU_50','WD_PU_75','WD_PU_100','WD_PU_200','WD_PU_250','WD_PU_500','WD_PU_1000']   
rpTime = [5, 10, 20, 50, 75, 100, 200, 250, 500, 1000] # return period (year)

baseline = baseCost
penalty = 0    
disUC=[]    
for i in range(10):
    start = time.clock()    
    disUC.append(disrupt(rperiod[i],G2,penalty,{}, baseline)) # total $ value of extra user cost because of disruption
    print(time.clock() - start, 'seconds')  

disruptC=[]
disruptT =[] 
avgC =[]
isolationT =[]
repairC =[]
base = np.sum(np.multiply(baseCost, T))/np.sum(T)
for i in range(10):
    disruptC.append(np.sum(disUC[i][0]))
    disruptT.append(np.sum(disUC[i][1]))
    isolationT.append(np.sum(disUC[i][2]))
    repairC.append((disUC[i][6]+disUC[i][7]+disUC[i][8])/1e6)
    
    if disruptT[i] !=0:
        avgC.append(disruptC[i]/disruptT[i])
increment = avgC/base
tripYear = np.sum(T)*362/1e6


# find the annual expectation
EAUC=0
EAUL=0
    
for i in range(9):                
    EAUC = EAUC + (1.0/rpTime[i]-1.0/rpTime[i+1])*(np.sum(disUC[i][0])+np.sum(disUC[i+1][0]))
    EAUL = EAUL + (1.0/rpTime[i]-1.0/rpTime[i+1])*(np.sum(disUC[i][2])+np.sum(disUC[i+1][2]))
EAUC = EAUC/2
EAUL = EAUL/2    

print 'Expected total user disruption cost is $', EAUC, 'million per year'
print 'Expected total isolation trips is',EAUL,'million per year.'
    
    
# total repair cost     
EARC=0   
for i in range(9):   
    EARC = EARC + (1.0/rpTime[i]-1.0/rpTime[i+1])*\
                  ((disUC[i][6]+disUC[i][7] + disUC[i][8])+(disUC[i+1][6]+disUC[i+1][7] + disUC[i+1][8]))
EARC = EARC/2 
print('Expected repair  cost is $', EARC,'million per year')

# In[]: Find the maximum repair cost for all infratructure when completely destroy

bridgeRC = 40000/1e6 # repair cost $
culvertRC = 10000/1e6
crossingRC = 1000/1e6
maxRC=[]    
for i in range(len(df_structure)):
    l = float(df_structure['Length'][i]) 
    if np.isnan(l):
        l=10
    b = float(df_structure['TotalWidth'][i] )
    if np.isnan(b):
        b=3
    item = df_structure['OBJECTID'][i]    
    if dic_strType[item] == 'Bridge' or dic_strType[item] == 'Footbridge': 
        maxRC.append(bridgeRC* l* b )
    if dic_strType[item] == 'Culvert': 
        maxRC.append(culvertRC* l* b )
    if dic_strType[item] == 'Crossing': 
        maxRC.append(crossingRC * l* b)
    
sum_RC = np.sum(maxRC)    
       